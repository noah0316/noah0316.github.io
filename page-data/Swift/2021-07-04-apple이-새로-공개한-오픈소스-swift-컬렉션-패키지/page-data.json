{"componentChunkName":"component---src-templates-blog-post-js","path":"/Swift/2021-07-04-apple이-새로-공개한-오픈소스-swift-컬렉션-패키지/","result":{"data":{"site":{"siteMetadata":{"title":"Noah's Dev Log","author":"[SeungHyun]","siteUrl":"https://noah0316.github.io","comment":{"disqusShortName":"","utterances":"noah0316/noah0316.github.io"},"sponsor":{"buyMeACoffeeId":"noah0316"}}},"markdownRemark":{"id":"dffc8ab6-28b0-5f5b-8f35-0cd6b737b1f5","excerpt":"안녕하세요 noah입니다 :) 오늘은 Swift 컬렉션 패키지에 대해 소개해보려 합니다. 요즘 알고리즘 문제 풀이를 하며 Swift에서 제공하는 여러 자료구조에 대해 찾아보던 중 2021년 4월 5일 Apple이 공개한 Swift 컬렉션 패키지를 알게 되었습니다. Swift의 공식 blog 글에 따르면 이번에 새로 공개한 Swift 컬렉션 패키지에서는 3가지의 범용 데이터 구조인 Array, Set 그리고, Dictionary를 위한 새로운 기능을 제공한다고 합니다. Deque Deque…","html":"<p>안녕하세요 noah입니다 :)<br>\n오늘은 <strong>Swift 컬렉션 패키지</strong>에 대해 소개해보려 합니다.</p>\n<p>요즘 알고리즘 문제 풀이를 하며 Swift에서 제공하는 여러 자료구조에 대해 찾아보던 중</p>\n<p>2021년 4월 5일 <strong>Apple</strong>이 공개한 <strong>Swift 컬렉션 패키지</strong>를 알게 되었습니다.</p>\n<p>Swift의 공식 blog 글에 따르면 이번에 새로 공개한 Swift 컬렉션 패키지에서는 3가지의 범용 데이터 구조인<br>\nArray, Set 그리고, Dictionary를 위한 새로운 기능을 제공한다고 합니다.</p>\n<h2 id=\"deque\" style=\"position:relative;\"><a href=\"#deque\" aria-label=\"deque permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deque</h2>\n<p><strong>Deque</strong>은(“deck”이라고 발음합니다.) 마치 Array처럼 동작합니다.</p>\n<p><strong>Deque</strong>은 <strong>Double ended queue</strong>의 줄임말로 stack이나 queue처럼</p>\n<p>한 방향에서 삽입과 삭제가 일어나는 게 아닌 <strong>‘양방향’</strong>에서 <strong>삽입</strong>과 <strong>삭제</strong>가 일어나는 구조입니다.</p>\n<p align=\"center\">\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 37.423312883435585%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABMklEQVQoz12RW0/DMAyF+///GEJCe+SBMTYE3dam7dLcmusOdrrBxMMnJ7Zzcpw0KWUEKyG6M7q+xzAMEEJAa42UEnLOK6Uge8rZC3KKf/kb3Ms0mQ8VIAO/jYW4Xq81lkKRxRZZBXnP4mutrP0PsfFWwX9skMy8ipJQphvYeY1hIVcTidm6rwYeSGyCY4zw3qPhg1ELhN0z4veWhDVy9HQ4VEcVdlsvu03yj3st8sghBKSyOovDF+J+g7h9Qnh/QWx3iGNHnKl2WhFHxI76jgeEzzeEwytCe4Bv9wiLozesj5rq/OV+W7A05khueyTZIstjJTHzCUl3BNXUGdnQJznu13X0hn/GWgvnHIwxUPOMWWlMF4lJKhi3QFsHZSwunKecGCf0YqxrSTk5KwzjWDV+AFbIHzo7qkygAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"1\" src=\"/static/2cdd19c9d2bfcd1afdd0e9e6897949a1/a6d36/1.png\" srcset=\"/static/2cdd19c9d2bfcd1afdd0e9e6897949a1/222b7/1.png 163w,\n/static/2cdd19c9d2bfcd1afdd0e9e6897949a1/ff46a/1.png 325w,\n/static/2cdd19c9d2bfcd1afdd0e9e6897949a1/a6d36/1.png 650w,\n/static/2cdd19c9d2bfcd1afdd0e9e6897949a1/e548f/1.png 975w,\n/static/2cdd19c9d2bfcd1afdd0e9e6897949a1/3c492/1.png 1300w,\n/static/2cdd19c9d2bfcd1afdd0e9e6897949a1/c2d13/1.png 2560w\" sizes=\"(max-width: 650px) 100vw, 650px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n</p><center>Benchmark</center>\n<p></p>\n<p><strong>양방향</strong>으로 <strong>삽입</strong>과 <strong>삭제</strong>가 일어나기 때문에<br>\n<strong>Array</strong>보다 <strong>월등히 좋은 성능</strong>을 보임을 그래프를 통해 알 수 있습니다.</p>\n<blockquote>\n<p>해당 <a href=\"https://github.com/apple/swift-collections/tree/main/Documentation/Announcement-benchmarks\">benchmarks</a>는 2017 iMac Pro에서 실행되었고,<br>\n모든 그래프는 <a href=\"https://darrengwon.tistory.com/789\">log-log</a> scale로 평균 처리 시간을 표시한 것이며<br>\n낮을수록 좋습니다.</p>\n</blockquote>\n<p>First-in-First-out queue가 필요할 때 deque을 선택하면 효율적으로 데이터를 처리할 수 있을 것입니다.</p>\n<p><strong>deque</strong>의 <strong>사용법</strong>은 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">import</span> <span class=\"token builtin\">Collections</span>\n\n<span class=\"token keyword\">var</span> colors<span class=\"token punctuation\">:</span> <span class=\"token builtin\">Deque</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"yellow\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">]</span>\n\ncolors<span class=\"token punctuation\">.</span><span class=\"token function\">prepend</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"green\"</span><span class=\"token punctuation\">)</span>\ncolors<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"orange\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// `colors` is now [\"green\", \"red\", \"yellow\", \"blue\", \"orange\"]</span>\n\ncolors<span class=\"token punctuation\">.</span><span class=\"token function\">popFirst</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// \"green\"</span>\ncolors<span class=\"token punctuation\">.</span><span class=\"token function\">popLast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// \"orange\"</span>\n<span class=\"token comment\">// `colors` is back to [\"red\", \"yellow\", \"blue\"]</span></code></pre></div>\n<p>앞부분에 item을 삽입/삭제를 할 필요가 없는 상황에서는 Array보다 약간 느리게 작동하므로<br>\n모든 Array를 deque로 대체하는 것은 좋지 않을 수 있습니다.</p>\n<h2 id=\"orderedset\" style=\"position:relative;\"><a href=\"#orderedset\" aria-label=\"orderedset permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OrderedSet</h2>\n<p><strong>OrderedSet</strong>은 강력한 <strong>Array</strong>와 <strong>Set</strong>의 <strong>hybrid</strong>입니다.</p>\n<p>원래 Set은 순서를 가지지 않으며, 중복 없이 한 번만 저장되어야 하는 데이터들을 다룰 때<br>\nArray 대신 사용했던 자료형입니다.</p>\n<p>Hashable 프로토콜을 준수하는 타입은 Set의 element type이 될 수 있습니다.<br>\n(Hash 연산하는 방법을 제공해야 합니다.)</p>\n<blockquote>\n<p>Swift에서 제공하는 모든 기본 type은 기본적으로 Hash 연산을 할 수 있습니다.</p>\n</blockquote>\n<p>OrderedSet을 이용하면 순서를 가지는 <strong>정렬 된 Set</strong>을 만들 수 있습니다.</p>\n<p>역시 Set과 마찬가지로 중복되는 element는 제거됩니다.</p>\n<p>사용법은 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">import</span> <span class=\"token builtin\">Collections</span>\n\n<span class=\"token keyword\">let</span> buildingMaterials<span class=\"token punctuation\">:</span> <span class=\"token builtin\">OrderedSet</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"straw\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"sticks\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bricks\"</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span> buildingMaterials<span class=\"token punctuation\">.</span><span class=\"token builtin\">count</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Little piggie #<span class=\"token interpolation\"><span class=\"token delimiter variable\">\\(</span>i<span class=\"token delimiter variable\">)</span></span> built a house of <span class=\"token interpolation\"><span class=\"token delimiter variable\">\\(</span>buildingMaterials<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token delimiter variable\">)</span></span>\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Little piggie #0 built a house of straw</span>\n<span class=\"token comment\">// Little piggie #1 built a house of sticks</span>\n<span class=\"token comment\">// Little piggie #2 built a house of bricks</span></code></pre></div>\n<p>기존의 Set은 원래 순서가 없지만, Set의 sort()를 사용하면 정렬된 결과를 반환받을 수 있었습니다.</p>\n<p>하지만 <strong>집합 자체에 순서가 부여</strong>되는 것이 아니었기 때문에 이 부분에서</p>\n<p>기존의 Set과 다른 의미를 가지는 것 같습니다.</p>\n<h2 id=\"ordereddictionary\" style=\"position:relative;\"><a href=\"#ordereddictionary\" aria-label=\"ordereddictionary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OrderedDictionary</h2>\n<p>원래 우리가 기존에 사용하던 Dictionary 역시 순서를 가지지 않았습니다.</p>\n<p><strong>OrdredDictionary</strong>는 요소의 <strong>순서가 중요</strong>하거나,</p>\n<p>컬렉션 내의 <strong>다양한 위치</strong>에서 요소에 <strong>효율적으로 접근</strong> 해야 하는 경우에 유용하게 쓰입니다.</p>\n<p>기존의 Dictionary와 마찬가지로 Hashable 프로토콜을 준수하는 타입은</p>\n<p>OrdredDictionary의 Key가 될 수 있습니다.</p>\n<p>사용법은 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">import</span> <span class=\"token builtin\">Collections</span>\n\n<span class=\"token keyword\">let</span> responses<span class=\"token punctuation\">:</span> <span class=\"token builtin\">OrderedDictionary</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token number\">200</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"OK\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">403</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Forbidden\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">404</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Not Found\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span>\n\nresponses<span class=\"token punctuation\">[</span><span class=\"token number\">200</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// \"OK\"</span>\nresponses<span class=\"token punctuation\">[</span><span class=\"token number\">500</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Internal Server Error\"</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>code<span class=\"token punctuation\">,</span> phrase<span class=\"token punctuation\">)</span> <span class=\"token keyword\">in</span> responses <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token delimiter variable\">\\(</span>code<span class=\"token delimiter variable\">)</span></span> (<span class=\"token interpolation\"><span class=\"token delimiter variable\">\\(</span>phrase<span class=\"token delimiter variable\">)</span></span>)\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 200 (OK)</span>\n<span class=\"token comment\">// 403 (Forbidden)</span>\n<span class=\"token comment\">// 404 (Not Found)</span>\n<span class=\"token comment\">// 500 (Internal Server Error)</span></code></pre></div>\n<p>OrderedDictionary는 정수형 index를 사용하며 첫 번째 요소는 항상 0으로 시작합니다.</p>\n<p>key-base와 index-base의 모호성을 피하고자 key-value pair에 대한 random-access를 지원합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\">responses<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// nil (key-based subscript)</span>\nresponses<span class=\"token punctuation\">.</span>elements<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// (200, \"OK\") (index-based subscript)</span></code></pre></div>\n<h2 id=\"아\" style=\"position:relative;\"><a href=\"#%EC%95%84\" aria-label=\"아 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아…</h2>\n<p>이 좋은 패키지는 Swift에 내장되어있는 것이 아닌,</p>\n<p>Swift Package Manager를 통해 설치한 다음 import를 하는 과정을 거쳐야 하므로</p>\n<p><strong>알고리즘 테스트</strong>에서는 사용하지 못할 것 같습니다🥺🥺</p>\n<p>Swift에 내장되는 날을 기다리며..🥳</p>\n<p>여기까지 2021년 4월 5일 <strong>Apple</strong>이 공개한 <strong>Swift 컬렉션 패키지</strong>에 대해 간략하게 알아보았습니다!</p>\n<p>혹시 제가 잘못 알고 있는 부분이 있거나, 오타 혹은 궁금한 점 있으시면 댓글로 알려주시면 감사하겠습니다!!😎</p>\n<blockquote>\n<p>참고</p>\n<ul>\n<li><a href=\"https://swift.org/blog/swift-collections/\">Introducing Swift Collections</a></li>\n</ul>\n</blockquote>","frontmatter":{"title":"Apple이 새로 공개한 오픈소스 Swift 컬렉션 패키지!","date":"July 04, 2021"}}},"pageContext":{"slug":"/Swift/2021-07-04-apple이-새로-공개한-오픈소스-swift-컬렉션-패키지/","previous":{"fields":{"slug":"/Algorithms/2021-06-24-해시-알고리즘(hash-algorithm)/"},"frontmatter":{"title":"해시 알고리즘(Hash algorithm)","category":"Algorithms","draft":false}},"next":{"fields":{"slug":"/Algorithms/2021-07-05-selection-sort/"},"frontmatter":{"title":"Swift Selection Sort(선택정렬)","category":"Algorithms","draft":false}}}}}